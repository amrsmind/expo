{"version":3,"file":"spawnAsync.js","sourceRoot":"","sources":["../../src/utils/spawnAsync.ts"],"names":[],"mappings":";;AAAA,iDAAoD;AAEpD;;;GAGG;AACY,KAAK,UAAU,UAAU,CACtC,OAAe,EACf,OAA0B,EAAE,EAC5B,UAAwB,EAAE;IAE1B,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAC9C,MAAM,KAAK,GAAG,IAAA,qBAAK,EAAC,OAAO,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QAC5C,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,MAAM,GAAG,EAAE,CAAC;QAEhB,IAAI,KAAK,CAAC,MAAM,EAAE;YAChB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE;gBAC/B,MAAM,IAAI,IAAI,CAAC;YACjB,CAAC,CAAC,CAAC;SACJ;QAED,IAAI,KAAK,CAAC,MAAM,EAAE;YAChB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE;gBAC/B,MAAM,IAAI,IAAI,CAAC;YACjB,CAAC,CAAC,CAAC;SACJ;QAED,MAAM,kBAAkB,GAAG,CAAC,IAAmB,EAAE,MAAqB,EAAE,EAAE;YACxE,KAAK,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;YAC7C,IAAI,IAAI,KAAK,CAAC,EAAE;gBACd,MAAM,CACJ,MAAM;oBACJ,CAAC,CAAC,IAAI,KAAK,CAAC,GAAG,OAAO,wBAAwB,MAAM,KAAK,MAAM,EAAE,CAAC;oBAClE,CAAC,CAAC,IAAI,KAAK,CAAC,GAAG,OAAO,+BAA+B,IAAI,KAAK,MAAM,EAAE,CAAC,CAC1E,CAAC;aACH;iBAAM;gBACL,OAAO,CAAC,MAAM,CAAC,CAAC;aACjB;QACH,CAAC,CAAC;QAEF,IAAI,aAAa,GAAG,CAAC,KAAY,EAAE,EAAE;YACnC,KAAK,CAAC,cAAc,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;YAClD,MAAM,CAAC,KAAK,CAAC,CAAC;QAChB,CAAC,CAAC;QAEF,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;QACxC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;IACrC,CAAC,CAAoB,CAAC;IACtB,OAAO,OAAO,CAAC;AACjB,CAAC;AA5CD,6BA4CC","sourcesContent":["import { spawn, SpawnOptions } from 'child_process';\n\n/**\n * Lightweight version of @expo/spawn-async. Returns a promise that is fulfilled with the output of\n * stdout, or rejected with the error event object (or the output of stderr).\n */\nexport default async function spawnAsync(\n  command: string,\n  args: readonly string[] = [],\n  options: SpawnOptions = {}\n): Promise<string> {\n  const promise = new Promise((resolve, reject) => {\n    const child = spawn(command, args, options);\n    let stdout = '';\n    let stderr = '';\n\n    if (child.stdout) {\n      child.stdout.on('data', (data) => {\n        stdout += data;\n      });\n    }\n\n    if (child.stderr) {\n      child.stderr.on('data', (data) => {\n        stderr += data;\n      });\n    }\n\n    const completionListener = (code: number | null, signal: string | null) => {\n      child.removeListener('error', errorListener);\n      if (code !== 0) {\n        reject(\n          signal\n            ? new Error(`${command} exited with signal: ${signal}\\n${stderr}`)\n            : new Error(`${command} exited with non-zero code: ${code}\\n${stderr}`)\n        );\n      } else {\n        resolve(stdout);\n      }\n    };\n\n    let errorListener = (error: Error) => {\n      child.removeListener('close', completionListener);\n      reject(error);\n    };\n\n    child.once('close', completionListener);\n    child.once('error', errorListener);\n  }) as Promise<string>;\n  return promise;\n}\n"]}